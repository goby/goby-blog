---
title: 分布式系统理论基础摘要
keywords: distsys
uuid: 5d5b956c-2f79-4f8b-bda7-4ea79dfbce21
tags:
 - tech
---

## 时钟

时钟的作用就是让我们知道事件的先后顺序、状态的变化过程先后。
以前不知道为什么 spanner 要弄个 GPS + 原子钟， 后来了解分布式系统
中时钟的作用，才能深刻理解。 时钟就是为了给不同数据中心的事务确定先后
顺序。

现在多核时代，不同的CPU之间其实也存在时钟同步问题。接下来就需要安排详读 
[Hrtimers and Beyoung: Transforming the Linux Time Subsystems](https://www.landley.net/kdocs/ols/2006/ols2006v1-pages-333-346.pdf)


###  什么是 wall clock?

就是 `<sys/time.h>` 内的时间，或者说我们常调用的 `gettimeofday()` 就是。
通常它只能让我们得到偏序的结果(即 inner-process events 的顺序)。
但这个有什么问题呢？ 为什么大家要研究时钟问题？

+ NTP并不是如我们想象的那么美好，
+ 节点间无法完全同步，节点间的网络传输有时延，处理有耗时，不能确定节点间
通信通道的稳定性
+ 硬件时钟有偏差，时钟会漂移(比如常规晶振的精度，一天延迟个几毫秒也是很常见)
+ By Centuries ????
+ 按照定义， [POSIX 时间](https://en.wikipedia.org/wiki/Unix_time)并非单调，
为什么这么说呢？因为 POSIX 时间采用格列高历，有闰秒的考虑(比如今天 2017-1-1 07:59:59 CST)
这里就多了1s，导致 POSIX 时间在这里可能会回退 1s。实际上，最好用 TAI，国际原子时，
每天严格 86400s ，不会考虑任何闰秒
+ 想要的时间精度并不一定能够达到
+ 线程可能会睡眠
+ 运行时可能睡眠，例如电源管理器为了省电， 给 CPU 降频
+ [系统/硬件可能休眠](https://events.linuxfoundation.org/slides/2011/linuxcon-japan/lcj2011_wysocki.pdf)

总而言之，最好别用（也可以看看 areiz 与 XXX 关于 Redis Lock 的讨论）。

### 什么是 lamport clock?

来自 Lamport 著名的论文 [Times, Clocks and Ordering of Events in Distributed Systems](http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf)

每个进程单独计时，每次变更时间+1，单调递增，每次信息传递都附上时间。 收到信息， t' = max(t, t_msg+1)
如果我们有一堆全序的进程，那么产生的事件也是全序的，但是可能反直觉(?)

### 什么是矢量时钟？

[Why Logical Clocks Are Easy](http://cacm.acm.org/magazines/2016/4/200168-why-logical-clocks-are-easy/abstract)

+ 将 Lamport Clock 变成所有进程的时钟向量， $v = [t_1...t_n]$
+ $t_i' = max(t_i, t_{msg,i})$
+ 对于进程 $p_i$， 一旦执行操作，则增加向量中 $v'(p_i) = v(p_i) + 1$
+ 提供偏序因果，即：
  + $A < B$， 当且仅当 $ A_i <= B_i $，且存在 `k`，使得 $A_k < B_k$